Билет №1:
1.  Параметризация типов. Ковариантность. Контрвариатность. Инвариатность. Использование WildCard.
2. 	Spring boot – что это такое и для чего используется. Основные составляющие Spring. Как устроен, что позволяет сделать. Какие есть аннотации. Основной скелет проекта. Аннотации @Repository, @Component, @Bean, @SpringBootApplication, @Service, @Entity, @Controller, @RestController, @Configuration, @Valid и другие. Конфигурационные файлы *.yaml,*.conf,*.properties. Swagger. Основные библиотеки и плагины в gradle для работы с БД, валидацией, MVC, UI.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в MongoDB находим документ, который содержит в поле test_field значение из первого сообщения Kafka ("test") и возвращаем в endpoint значение поля test_value_field из документа MongoDB в верхнем регистре и с обратным порядком букв

Билет №2:
1.  Классы, интерфейсы и перечисления. Ключевые слова abstract, interface, enum, default. Разница между абстрактным классом и интерфейсом. Вложенные классы.
2. 	Logback и конфигурация логирования - logback.xml. Логирование в Java. Jackson – работа с JSON. Конфигурирование Java приложений с помощью typesafe config.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в PostgreSQL находим все строки, которые содержат сообщение Kafka ("test") и возвращаем в endpoint общее количество найденных слов, разделённых пробелами

Билет №3:
1.  Классы, интерфейсы и перечисления. Ключевые слова abstract, interface, enum, default. Разница между абстрактным классом и интерфейсом. Вложенные классы.
2. 	MongoDB – как устроена и для чего используется. Модель данных в MongoDB. Как производить поиск, вставку и удаления данных из MongoDB. Как в Java работать с MongoDB.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в Redis находим строку, по ключу первого сообщения из Kafka ("test") и возвращаем в endpoint значение из Redis, но без каждого второго символа

Билет №4:
1.  Многопоточность. Пуллы потоков. ExecutorService. Executors.
2.  Что такое аутентификация. Чем аутентификация отличается от авторизация. Что такое JWT токен. Аутентификация с помощью JWT токена. Аутентификация с помощью сессионного токена, хранящегося в Redis. Сравнение аутентификации с помощью JWT токена и сессионного токена, хранящего в Redis - плюсы и минусы каждого подхода
3.  Реализуйте аутентификацию с помощью токенов, хранящихся в Redis. Токен должен быть строкой UUID. TTL токена должен задаваться в конфигурации приложения Spring в файле application.yml. Для реализации аутентификации нужно использовать Spring Security. Для проверки реализуйте класс TokenVerification, который будет использован в FilterChain, с одним методом boolean verify(UUID token), внутри которого происходит проверка наличия в Redis и проверка срока действия. Для выдачи токена реализуйте эндпоинт /api/v1/mai/register, который будет отдавать строку UUID - токен пользователя.

Билет №5:
1.  Класс ArrayDeque. Основные реализации. Как работают вставка, удаление, поиск элемента на примере одной из реализаций.
2. 	Logback и конфигурация логирования - logback.xml. Логирование в Java. Jackson – работа с JSON. Конфигурирование Java приложений с помощью typesafe config.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в Redis находим строку, по ключу первого сообщения из Kafka ("test") и возвращаем в endpoint значение из Redis в верхнем регистре и с обратным порядком букв

Билет №6:
1.  Многопоточность. Ключевые слова volatile, synchronized. Методы notify, notifyAll, wait.
2. 	PostgreSQL – как устроен и для чего используется. Модель данных в PostgreSQL. Как в Java работать с PostgreSQL.
3.  Реализуйте аутентификацию с помощью токенов, хранящихся в Redis. Токен должен быть строкой UUID. TTL токена должен задаваться в конфигурации приложения Spring в файле application.yml. Для реализации аутентификации нужно использовать Spring Security. Для проверки реализуйте класс TokenVerification, который будет использован в FilterChain, с одним методом boolean verify(UUID token), внутри которого происходит проверка наличия в Redis и проверка срока действия. Для выдачи токена реализуйте эндпоинт /api/v1/mai/register, который будет отдавать строку UUID - токен пользователя.

Билет №7:
1.  Сетевое взаимодействие клиент-сервер в Java. Основные классы и методы для работы с сетью.
2. 	Gradle – что это и для чего используется. Рассказать про разные области видимости в dependency, основные таски – clean, build, jar и другие.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в MongoDB находим документ, который содержит в поле test_field значение из первого сообщения Kafka ("test") и возвращаем в endpoint значение поля test_value_field из документа MongoDB в верхнем регистре и с обратным порядком букв

Билет №8:
1.  Коллекции Java. Иерархия классов и интерфейсов для коллекций. Примеры.
2.  Что такое unit-тесты. Почему они важны. Какие есть основные принципы написания unit-тестов. Чем unit-тесты отличаются от интеграционных.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в PostgreSQL находим все строки, которые содержат сообщение Kafka ("test") и возвращаем в endpoint из найденных строк значение из поля test_value с максимальным id

Билет №9:
1.  Исключения. Обработка исключений. Проверяемые и непроверяемые исключения. Ключевые слова при использовании исключений.
2. 	JOOQ – что это и для чего используется. Рассказать про аннотации в Java из JOOQ. Как подключить, как работает.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в PostgreSQL находим все строки, которые содержат сообщение Kafka ("test") и возвращаем в endpoint значение с самым большим id из PostgreSQL

Билет №10:
1.  Условные операторы(if/else,switch). Операторы циклов (while,do/while,for,foreach,StreamAPI forEach). Интерфейсы Comparable, Comparator. Iterable, Iterator.
2.  Паттерн SAGA. Что такое оркестратор. Реализация через REST. Реализация через событийную модель (Kafka). Плюсы и минусы каждого подхода. Главные минусы событийной реализации SAGA. Реализация распределенных транзакций.
3.  Создайте простое приложение Spring Boot. Реализуйте отображение основных метрик JVM приложения в Grafana. Для конфигурирования dashboard в Grafana используйте файл grafana.json из лабораторной работы №7.

Билет №11:
1.  Условные операторы(if/else,switch). Операторы циклов (while,do/while,for,foreach,StreamAPI forEach). Интерфейсы Comparable, Comparator. Iterable, Iterator.
2. 	JOOQ – что это и для чего используется. Рассказать про аннотации в Java из JOOQ. Как подключить, как работает.
3.  Создайте простое приложение Spring Boot - CRUD для таблицы student, которая состоит из полей id, name, group. Схему для БД разработать самостоятельно. В приложении должно быть 4 эндпоинта - create, read, update, delete. При разработке приложения должно присутствовать 3 слоя - controller, service, repository. Напишите хотя бы по одному тесту на каждый метод каждого слоя

Билет №12:
1.  Основные методы для работы с коллекциями. Классы Collections, Arrays.
2. 	Spring boot – что это такое и для чего используется. Основные составляющие Spring. Как устроен, что позволяет сделать. Какие есть аннотации. Основной скелет проекта. Аннотации @Repository, @Component, @Bean, @SpringBootApplication, @Service, @Entity, @Controller, @RestController, @Configuration, @Valid и другие. Конфигурационные файлы *.yaml,*.conf,*.properties. Swagger. Основные библиотеки и плагины в gradle для работы с БД, валидацией, MVC, UI.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в PostgreSQL находим все строки, которые содержат сообщение Kafka ("test") и возвращаем в endpoint количество найденых строк в PostgreSQL.

Билет №13:
1.  Сетевое взаимодействие клиент-сервер в Java. Основные классы и методы для работы с сетью.
2.  Spring Security. Настройка аутентификации и авторизации. Какие есть основные компоненты и аннотации. Что такое CORS и CSRF. Какие есть формы авторизации и в чем отличия. Что такое FilterChain, AuthenticationManaer, AuthenticationProvider, UserDetailsService и как эти классы взаимодействуют.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в PostgreSQL находим все строки, которые содержат сообщение Kafka ("test") и возвращаем в endpoint количество найденых строк в PostgreSQL.

Билет №14:
1.  Java Memory Model - основные аспекты. Garbage Collector. Garbage Collector G1. СMS.
2.  Apache Kafka. Архитектура и основные компоненты. Как работает Producer и его основные конфигурации. Как работает Consumer и его основные конфигурации. Apache Zookeeper – для чего нужен и как устроен. Как работает брокер сообщений. Как устроен Message в Kafka. За счет чего Apache Kafka поддерживает надежность, высокую доступность и высокую производительность. Процесс отправки сообщения в Kafka. Процесс чтения сообщения из Kafka. Процесс удаления сообщения из Kafka. Как в Java работать с Kafka.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в MongoDB находим документ, который содержит в поле test_field значение из первого сообщения Kafka ("test") и возвращаем в endpoint значение поля test_value_field из документа MongoDB, но без каждого второго символа

Билет №15:
1.  Файлы в Java. Основные потоки чтения/записи. Основные методы работы с потоками чтения/записи.
2.  Что такое unit-тесты. Почему они важны. Какие есть основные принципы написания unit-тестов. Чем unit-тесты отличаются от интеграционных.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в PostgreSQL находим все строки, которые содержат сообщение Kafka ("test") и возвращаем в endpoint общее количество найденных слов, разделённых пробелами

Билет №16:
1.  Основные методы для работы с коллекциями. Классы Collections, Arrays.
2. 	Redis – как устроен и для чего используется. Модель данных в MongoDB. Типы данных в Redis. Процесс записи данных в Redis. Процесс чтения данных в Redis. Процесс удаления данных из Redis. За счет чего достигается высокая производительность. Как организовать очередь сообщений через Redis. Как в Java работать с Redis.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в MongoDB находим документ, который содержит в поле test_field значение из первого сообщения Kafka ("test") и возвращаем в endpoint значение поля test_value_field из документа MongoDB

Билет №17:
1.  Интерфейс Set<E>. Основные реализации. Как работают вставка, удаление, поиск элемента на примере одной из реализаций.
2. 	Docker – что это и для чего используется. Как устроен – основные компоненты. Основные команды и параметры для работы с docker. DockerHub. DockerFile. Docker compose. Docker Image. Как собрать собственный Image для Java приложения.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в PostgreSQL находим все строки, которые содержат сообщение Kafka ("test") и возвращаем в endpoint общее количество найденных слов, разделённых пробелами

Билет №18:
1.  Многопоточность. Интерфейсы Callable, Runnable, Future. Класс Thread.
2. 	Spring boot – что это такое и для чего используется. Основные составляющие Spring. Как устроен, что позволяет сделать. Какие есть аннотации. Основной скелет проекта. Аннотации @Repository, @Component, @Bean, @SpringBootApplication, @Service, @Entity, @Controller, @RestController, @Configuration, @Valid и другие. Конфигурационные файлы *.yaml,*.conf,*.properties. Swagger. Основные библиотеки и плагины в gradle для работы с БД, валидацией, MVC, UI.
3.  Реализуйте аутентификацию с помощью токенов, хранящихся в Redis. Токен должен быть строкой UUID. TTL токена должен задаваться в конфигурации приложения Spring в файле application.yml. Для реализации аутентификации нужно использовать Spring Security. Для проверки реализуйте класс TokenVerification, который будет использован в FilterChain, с одним методом boolean verify(UUID token), внутри которого происходит проверка наличия в Redis и проверка срока действия. Для выдачи токена реализуйте эндпоинт /api/v1/mai/register, который будет отдавать строку UUID - токен пользователя.

Билет №19:
1.  Коллекции Java. Иерархия классов и интерфейсов для коллекций. Примеры.
2.  Паттерн SAGA. Что такое оркестратор. Реализация через REST. Реализация через событийную модель (Kafka). Плюсы и минусы каждого подхода. Главные минусы событийной реализации SAGA. Реализация распределенных транзакций.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в PostgreSQL находим все строки, которые содержат сообщение Kafka ("test") и возвращаем в endpoint из найденных строк значение из поля test_value с максимальным id

Билет №20:
1.  Класс Object, его методы, правила переопределения методов, использование класса.
2. 	MongoDB – как устроена и для чего используется. Модель данных в MongoDB. Как производить поиск, вставку и удаления данных из MongoDB. Как в Java работать с MongoDB.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в Redis находим строку, по ключу первого сообщения из Kafka ("test") и возвращаем в endpoint значение из Redis в верхнем регистре и с обратным порядком букв

Билет №21:
1.  Класс ArrayList, LinkedList. Основные реализации. Как работают вставка, удаление, поиск элемента на примере реализаций.
2.  Архитектура и основные компоненты. Как работает Producer и его основные конфигурации. Как работает Consumer и его основные конфигурации. Apache Zookeeper – для чего нужен и как устроен. Как работает брокер сообщений. Как устроен Message в Kafka. За счет чего Apache Kafka поддерживает надежность, высокую доступность и высокую производительность. Процесс отправки сообщения в Kafka. Процесс чтения сообщения из Kafka. Процесс удаления сообщения из Kafka. Как в Java работать с Kafka.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в PostgreSQL находим все строки, которые содержат сообщение Kafka ("test") и возвращаем в endpoint значение с самым большим id из PostgreSQL

Билет №22:
1.  Исключения. Обработка исключений. Проверяемые и непроверяемые исключения. Ключевые слова при использовании исключений.
2. 	PostgreSQL – как устроен и для чего используется. Модель данных в PostgreSQL. Как в Java работать с PostgreSQL.
3.  Создайте простое приложение Spring Boot - CRUD для таблицы student, которая состоит из полей id, name, group. Схему для БД разработать самостоятельно. В приложении должно быть 4 эндпоинта - create, read, update, delete. При разработке приложения должно присутствовать 3 слоя - controller, service, repository. Напишите хотя бы по одному тесту на каждый метод каждого слоя

Билет №23:
1.  Интерфейс Map<K,V>. Основные реализации. Как работают вставка, удаление, поиск элемента на примере одной из реализаций.
2. 	Docker – что это и для чего используется. Как устроен – основные компоненты. Основные команды и параметры для работы с docker. DockerHub. DockerFile. Docker compose. Docker Image. Как собрать собственный Image для Java приложения.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в Redis находим строку, по ключчу первого сообщения из Kafka ("test") и возвращаем в endpoint значение из Redis

Билет №24:
1.  Stream API. Лямбда-выражения. Основные методы создания, трансформации и агрегации данных.
2.  Что такое аутентификация. Чем аутентификация отличается от авторизация. Что такое JWT токен. Аутентификация с помощью JWT токена. Аутентификация с помощью сессионного токена, хранящегося в Redis. Сравнение аутентификации с помощью JWT токена и сессионного токена, хранящего в Redis - плюсы и минусы каждого подхода
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в PostgreSQL находим все строки, которые содержат сообщение Kafka ("test") и возвращаем в endpoint из найденных строк значение из поля test_value с максимальным id

Билет №25:
1.  Интерфейс Set<E>. Основные реализации. Как работают вставка, удаление, поиск элемента на примере одной из реализаций.
2. 	Redis – как устроен и для чего используется. Модель данных в MongoDB. Типы данных в Redis. Процесс записи данных в Redis. Процесс чтения данных в Redis. Процесс удаления данных из Redis. За счет чего достигается высокая производительность. Как организовать очередь сообщений через Redis. Как в Java работать с Redis.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в MongoDB находим документ, который содержит в поле test_field значение из первого сообщения Kafka ("test") и возвращаем в endpoint значение поля test_value_field из документа MongoDB, но без каждого второго символа

Билет №26:
1.  Наследование, инкапсуляция, полиморфизм. Примеры использования. Ключевое слово final в наследовании. Аннотация @override.
2. 	Redis – как устроен и для чего используется. Модель данных в MongoDB. Типы данных в Redis. Процесс записи данных в Redis. Процесс чтения данных в Redis. Процесс удаления данных из Redis. За счет чего достигается высокая производительность. Как организовать очередь сообщений через Redis. Как в Java работать с Redis.
3.  Создайте простое приложение Spring Boot. Реализуйте отображение основных метрик JVM приложения в Grafana. Для конфигурирования dashboard в Grafana используйте файл grafana.json из лабораторной работы №7.

Билет №27:
1.  Наследование, инкапсуляция, полиморфизм. Примеры использования. Ключевое слово final в наследовании. Аннотация @override.
2. 	Gradle – что это и для чего используется. Рассказать про разные области видимости в dependency, основные таски – clean, build, jar и другие.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в MongoDB находим документ, который содержит в поле test_field значение из первого сообщения Kafka ("test") и возвращаем в endpoint значение поля test_value_field из документа MongoDB, но без каждого второго символа

Билет №28:
1.  Многопоточность. Интерфейсы Callable, Runnable, Future. Класс Thread.
2. 	HikariCP – что это и для чего используется. Какие есть альтернативы. Как работать в Java с HikariCP.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в Redis находим строку, по ключу первого сообщения из Kafka ("test") и возвращаем в endpoint значение из Redis, но без каждого второго символа

Билет №29:
1.  Java Memory Model - основные аспекты. Garbage Collector. Garbage Collector G1. СMS.
2. 	Logback и конфигурация логирования - logback.xml. Логирование в Java. Jackson – работа с JSON. Конфигурирование Java приложений с помощью typesafe config.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в Redis находим строку, по ключу первого сообщения из Kafka ("test") и возвращаем в endpoint значение из Redis в верхнем регистре и с обратным порядком букв

Билет №30:
1.  Многопоточность. Пуллы потоков. ExecutorService. Executors.
2.  Паттерн SAGA. Что такое оркестратор. Реализация через REST. Реализация через событийную модель (Kafka). Плюсы и минусы каждого подхода. Главные минусы событийной реализации SAGA. Реализация распределенных транзакций.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в PostgreSQL находим все строки, которые содержат сообщение Kafka ("test") и возвращаем в endpoint количество найденых строк в PostgreSQL.

Билет №31:
1.  Класс Object, его методы, правила переопределения методов, использование класса.
2. 	HikariCP – что это и для чего используется. Какие есть альтернативы. Как работать в Java с HikariCP.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в MongoDB находим документ, который содержит в поле test_field значение из первого сообщения Kafka ("test") и возвращаем в endpoint значение поля test_value_field из документа MongoDB

Билет №32:
1.  Неконтроллируемые ресурсы в Java. Интерфейс Autocloseable. try-with-resources. Метод finalize.
2. 	MongoDB – как устроена и для чего используется. Модель данных в MongoDB. Как производить поиск, вставку и удаления данных из MongoDB. Как в Java работать с MongoDB.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в PostgreSQL находим все строки, которые содержат сообщение Kafka ("test") и возвращаем в endpoint значение с самым большим id из PostgreSQL

Билет №33:
1.  Параметризация типов. Ковариантность. Контрвариатность. Инвариатность. Использование WildCard.
2.  Зачем нужны метрики. Что такое actuator. Основные эндпоинты для сбора метрик. Что такое prometheus, какую роль он играет для actuator и Grafana. Что такое Grafana, как происходит сбор метрик
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в Redis находим строку, по ключчу первого сообщения из Kafka ("test") и возвращаем в endpoint значение из Redis

Билет №34:
1.  Библиотека java.util.concurrent.*. Коллекции для работы с многопоточностью.
2.  Что такое unit-тесты. Почему они важны. Какие есть основные принципы написания unit-тестов. Чем unit-тесты отличаются от интеграционных.
3.  Создайте простое приложение Spring Boot - CRUD для таблицы student, которая состоит из полей id, name, group. Схему для БД разработать самостоятельно. В приложении должно быть 4 эндпоинта - create, read, update, delete. При разработке приложения должно присутствовать 3 слоя - controller, service, repository. Напишите хотя бы по одному тесту на каждый метод каждого слоя

Билет №35:
1.  Библиотека java.util.concurrent.*. Коллекции для работы с многопоточностью.
2. 	HikariCP – что это и для чего используется. Какие есть альтернативы. Как работать в Java с HikariCP.
3.  Создайте простое приложение Spring Boot. Реализуйте отображение основных метрик JVM приложения в Grafana. Для конфигурирования dashboard в Grafana используйте файл grafana.json из лабораторной работы №7.

Билет №36:
1.  Файлы в Java. Основные потоки чтения/записи. Основные методы работы с потоками чтения/записи.
2. 	Docker – что это и для чего используется. Как устроен – основные компоненты. Основные команды и параметры для работы с docker. DockerHub. DockerFile. Docker compose. Docker Image. Как собрать собственный Image для Java приложения.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в Redis находим строку, по ключчу первого сообщения из Kafka ("test") и возвращаем в endpoint значение из Redis

Билет №37:
1.  Интерфейс Map<K,V>. Основные реализации. Как работают вставка, удаление, поиск элемента на примере одной из реализаций.
2. 	Gradle – что это и для чего используется. Рассказать про разные области видимости в dependency, основные таски – clean, build, jar и другие.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в MongoDB находим документ, который содержит в поле test_field значение из первого сообщения Kafka ("test") и возвращаем в endpoint значение поля test_value_field из документа MongoDB в верхнем регистре и с обратным порядком букв

Билет №38:
1.  Класс ArrayList, LinkedList. Основные реализации. Как работают вставка, удаление, поиск элемента на примере реализаций.
2.  Apache Kafka. Архитектура и основные компоненты. Как работает Producer и его основные конфигурации. Как работает Consumer и его основные конфигурации. Apache Zookeeper – для чего нужен и как устроен. Как работает брокер сообщений. Как устроен Message в Kafka. За счет чего Apache Kafka поддерживает надежность, высокую доступность и высокую производительность. Процесс отправки сообщения в Kafka. Процесс чтения сообщения из Kafka. Процесс удаления сообщения из Kafka. Как в Java работать с Kafka.
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в Redis находим строку, по ключу первого сообщения из Kafka ("test") и возвращаем в endpoint значение из Redis, но без каждого второго символа

Билет №39:
1.  Многопоточность. Ключевые слова volatile, synchronized. Методы notify, notifyAll, wait.
2.  Что такое аутентификация. Чем аутентификация отличается от авторизация. Что такое JWT токен. Аутентификация с помощью JWT токена. Аутентификация с помощью сессионного токена, хранящегося в Redis. Сравнение аутентификации с помощью JWT токена и сессионного токена, хранящего в Redis - плюсы и минусы каждого подхода
3.  Реализовать endpoint в TaskController, которому при запросе передаётся boostrapServers и название топика. В endpoint создаётся consumer Kafka, который читает топик, начиная с самых старых сообщений. Далее в MongoDB находим документ, который содержит в поле test_field значение из первого сообщения Kafka ("test") и возвращаем в endpoint значение поля test_value_field из документа MongoDB
